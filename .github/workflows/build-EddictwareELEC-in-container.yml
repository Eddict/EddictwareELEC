name: Build image in container

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  workflow_dispatch:
    inputs:
      runner:
        description: 'Runner to run against'
        required: true
        type: choice
        options:
          - self-hosted
          - github
        default: self-hosted
      os:
        description: 'OS of build container'
        required: true
        type: choice
        options:
          - bookworm
          - jammy
          - noble
          - noble-custom
          - plucky
          - questing
          - sid
        default: noble
      arch:
        description: 'Arch of build target'
        required: true
        type: choice
        options:
          - amd64
          - aarch64
          - arm
          - x86_64
        default: aarch64
      debug:
        description: 'Enable debug build'
        required: true
        type: boolean
        default: false

run-name: ${{ format('{0} ({1}/{2}/{3})', github.workflow, github.event_name == 'workflow_dispatch' && inputs.runner || 'self-hosted', github.event_name == 'workflow_dispatch' && inputs.os || 'noble', github.event_name == 'workflow_dispatch' && inputs.arch || 'aarch64') }}

env:
  DistroCodeName: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.os || 'noble' }}
  EE_Distro: EddictwareELEC
  EE_Project: RPi
  EE_Device: RPi4
  EE_Arch: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.arch || 'aarch64' }}
  EE_image_pathfilename: ""
  EE_image_filename: ""
  # EE_Registry: ${{ secrets.REGISTRY_PRIVATE_FQDN }} # ${{ secrets.REGISTRY_FQDN }}
  EE_Registry: ghcr.io

defaults:
  run:
    shell: bash

jobs:
  init:
    runs-on: ${{ github.event_name == 'workflow_dispatch' && (inputs.runner == 'github' && 'ubuntu-latest' || inputs.runner) || 'ubuntu-latest' }}
    permissions:
      contents: read
      packages: read
      attestations: read
      id-token: write
    if: github.event.head_commit.author.username != 'Eddict' || github.event_name == 'workflow_dispatch'
      # && github.event_name != 'pull_request' && github.event_name != 'workflow_dispatch'
    env:
      BUILDKIT_PROGRESS: 'auto' #'plain' 'quiet'
    # Expose step outputs as job outputs
    outputs:
      output_ee_distro_tag: ${{ steps.compose-image-tag.outputs.EE_Distro_tag }}
      docker_guid: ${{ steps.get-docker-guid.outputs.docker_guid }}
    steps:
    - name: Get Date
      id: get-date
      run: |
        # echo "[date]: $(/bin/date -u "+%Y%m%d")"
        echo "date=$(/bin/date -u "+%Y%m%d")" >> $GITHUB_OUTPUT

    - name: Get docker guid
      id: get-docker-guid
      run: |
        echo "docker_guid=$(id -u docker 2>/dev/null || echo 1000)" >> $GITHUB_OUTPUT

    - name: Compose image tag
      id: compose-image-tag
      run: |
        # ghcr.io/eddict/eddictwareelec-questing:latest
        # echo "DistroCodeName=${DistroCodeName}"
        # echo "DistroCodeName@L=${DistroCodeName@L}"
        # EE_Distro_tag="${{ env.EE_Registry }}/eddict/${DistroCodeName@L}"
        # echo "EE_Distro_tag=${EE_Distro_tag}" >> $GITHUB_OUTPUT
        dTag="${{ env.EE_Registry }}/eddict/${{ env.EE_Distro }}-${DistroCodeName@L}:latest"
        # Use ,, to convert all characters to lowercase
        echo "EE_Distro_tag=${dTag,,}"
        echo "EE_Distro_tag=${dTag,,}" >> $GITHUB_OUTPUT

        # value=$(printf '%s' "$EE_Distro_tag" | sed 's/%25/%/g; s/%0D/\r/g; s/%0A/\n/g')
        # echo "value=$value"
        # echo "Trick to echo EE_Distro_tag:"
        # echo "$value" | sed 's/./& /g' | awk '{print substr($0,1,100);exit}'

        # value=$(printf '%s' "${{ secrets.REGISTRY_FQDN }}" | sed 's/%25/%/g; s/%0D/\r/g; s/%0A/\n/g')
        # echo "value=$value"
        # echo "Trick to echo REGISTRY_FQDN:"
        # echo "$value" | sed 's/./& /g' | awk '{print substr($0,1,100);exit}'

        # value=$(printf '%s' "${{ secrets.REGISTRY_PRIVATE_FQDN }}" | sed 's/%25/%/g; s/%0D/\r/g; s/%0A/\n/g')
        # echo "value=$value"
        # echo "Trick to echo REGISTRY_PRIVATE_FQDN:"
        # echo "$value" | sed 's/./& /g' | awk '{print substr($0,1,100);exit}'

        # value=$(printf '%s' "${{ secrets.REGISTRY_USER }}" | sed 's/%25/%/g; s/%0D/\r/g; s/%0A/\n/g')
        # echo "value=$value"
        # echo "Trick to echo REGISTRY_USER:"
        # echo "$value" | sed 's/./& /g' | awk '{print substr($0,1,100);exit}'

  build:
    runs-on: ${{ github.event_name == 'workflow_dispatch' && (inputs.runner == 'github' && 'ubuntu-latest' || inputs.runner) || 'ubuntu-latest' }}
    needs: init
    # container:
    #   image: ${{ needs.init.outputs.output_ee_distro_tag }}
    #   credentials:
    #     username: ${{ secrets.REGISTRY_USER }}
    #     password: ${{ secrets.REGISTRY_PWD }}
    steps:
    # - name: Echo out to the logs
    #   run: |
    #     value=$(printf '%s' "${{ needs.init.outputs.output_ee_distro_tag }}" | sed 's/%25/%/g; s/%0D/\r/g; s/%0A/\n/g')
    #     echo "Trick to echo output_ee_distro_tag:"
    #     echo "$value" | sed 's/./& /g' | awk '{print substr($0,1,60);exit}'
    #     # echo "$value" | sed 's/./& /g'
    #     value=$(printf '%s' "${{ env.EE_Registry }}" | sed 's/%25/%/g; s/%0D/\r/g; s/%0A/\n/g')
    #     echo "Trick to echo reg_fqdn:"
    #     echo "$value" | sed 's/./& /g' | awk '{print substr($0,1,70);exit}'
    #     # echo "$value" | sed 's/./& /g'

    - name: Log in to registry
      uses: docker/login-action@v3
      with:
        # registry: ${{ secrets.REGISTRY_PRIVATE_FQDN }} #https:// #:5000 
        # username: ${{ secrets.REGISTRY_USER }}
        # password: ${{ secrets.REGISTRY_PWD }}
        registry: ${{ env.EE_Registry }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # -
    #   name: Compose image tag
    #   id: compose-image-tag
    #   run: |
    #     echo "EE_Distro_tag=${{ secrets.REGISTRY_FQDN }}/${DistroCodeName@L}" >> $GITHUB_OUTPUT

    # -
    #   name: Cache Docker layers
    #   uses: actions/cache@v4
    #   with:
    #     path: /tmp/.buildx-cache-2
    #     key: ${{ runner.os }}-${{ github.repository }}-${{ github.ref_name }}--${{ github.ref_sha }}
    #     restore-keys: ${{ runner.os }}-${{ github.repository }}-${{ github.ref_name }}

    # - uses: docker://${{ needs.init.outputs.output_ee_distro_tag }}:latest       
    # - uses: docker://ghcr.io/<my-org>/<some-private-repo>/<some-private-image>:<tag>        

    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        ref: 'master'
        # clean: false

    - name: Restore build caches
      uses: actions/cache@v4
      with:
        path: |
          .ccache
          build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.ccache
          build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.stamps
          build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.cache_package_global
          sources
        key: ${{ runner.os }}-eddict-${{ env.DistroCodeName }}-${{ env.EE_Arch }}-ccache-${{ hashFiles('packages/**/package.mk') }}
        restore-keys: |
          ${{ runner.os }}-eddict-${{ env.DistroCodeName }}-${{ env.EE_Arch }}-ccache-

    - name: Restore apt cache
      uses: actions/cache@v4
      with:
        path: .apt-cache/archives
        key: ${{ runner.os }}-apt-${{ env.DistroCodeName }}-${{ env.EE_Arch }}-${{ hashFiles('tools/docker/**/Dockerfile') }}
        restore-keys: |
          ${{ runner.os }}-apt-${{ env.DistroCodeName }}-${{ env.EE_Arch }}-

    - name: Prepare cache dirs for container
      run: |
        BUILD_DIR="build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel"
        mkdir -p .ccache "$BUILD_DIR" .apt-cache/archives
        # ensure stamps dir exists so docker won't auto-create it as root when bind-mounting
        mkdir -p "$BUILD_DIR/.stamps"
        # ensure the global cache is a file (scripts expect a file, not a directory)
        if [ ! -e "$BUILD_DIR/.cache_package_global" ]; then
          touch "$BUILD_DIR/.cache_package_global"
        fi
        DOCKER_UID=${{ needs.init.outputs.docker_guid }}
        # use same GID as UID if we don't know the image GID (common in builder images)
        DOCKER_GID=${DOCKER_UID}
        # runner type (github or self-hosted) — default to 'github' for non-dispatch runs
        RUNNER_TYPE="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.runner || 'github' }}"
        echo "Preparing cache dirs for UID:GID ${DOCKER_UID}:${DOCKER_GID}"
        sudo chown -R ${DOCKER_UID}:${DOCKER_GID} .ccache "$BUILD_DIR" .apt-cache || true
        sudo chown -R ${DOCKER_UID}:${DOCKER_GID} "$BUILD_DIR/.stamps" || true
        sudo chown ${DOCKER_UID}:${DOCKER_GID} "$BUILD_DIR/.cache_package_global" || true
        # allow the container user to create/remove files in cache dirs
        chmod -R 0775 .ccache "$BUILD_DIR" .apt-cache || true
        chmod -R 0775 "$BUILD_DIR/.stamps" || true
        chmod 0664 "$BUILD_DIR/.cache_package_global" || true
        # On self-hosted runners make workspace ownership match container user for full parity
        if [ "${RUNNER_TYPE}" != "github" ]; then
          echo "Chowning workspace to ${DOCKER_UID}:${DOCKER_GID}"
          sudo chown -R ${DOCKER_UID}:${DOCKER_GID} "${GITHUB_WORKSPACE}" || true
        fi

    - name: Build ${{ env.EE_Distro }} image
      id: build-image
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        debug=${{ github.event.inputs.debug }}
        [ "$debug" = true ] && echo "[pwd]: $PWD"
        [ "$debug" = true ] && echo "[github.workspace]: ${{ github.workspace }}"
        [ "$debug" = true ] && ls -al $PWD
        # chown -R docker:docker $PWD
        # ls -al $PWD
        # docker login --username ${{ vars.DOCKERHUB_USERNAME }} --password ${{ secrets.DOCKERHUB_TOKEN }}
        # if [ "$(docker ps -aq -f status=exited -f name=build${{ env.EE_Distro }}.${{ env.DistroCodeName }})" ]; then
        #     # cleanup
        #     docker rm --force --volumes "build${{ env.EE_Distro }}.${{ env.DistroCodeName }}"
        # fi
        # set some build performance flags
        NB_CORES=$(grep -c '^processor' /proc/cpuinfo)
        [ "$debug" = true ] && echo "[NB_CORES]: $NB_CORES"

        # pull the image (authentication is handled by docker/login-action@v3)
        docker --debug image pull "${{ needs.init.outputs.output_ee_distro_tag }}"
        # Diagnostic: run a short container to print UID/GID and test writing to cache dirs
        BUILD_DIR="build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel"
        # decide mount strategy based on runner input: use named docker volumes only on self-hosted runners
        DOCKER_UID=${{ needs.init.outputs.docker_guid }}
        DOCKER_GID=${DOCKER_UID}
        # runner type (github or self-hosted) — default to 'github' for non-dispatch runs
        RUNNER_TYPE="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.runner || 'github' }}"
        [ "$debug" = true ] && echo "[RUNNER_TYPE]: $RUNNER_TYPE"
        # make the volume prefix target-specific from EE_Distro (distro + codename + arch)
        VOLUME_PREFIX="${{ env.EE_Distro }}-${{ env.DistroCodeName }}-${{ env.EE_Arch }}"
        [ "$debug" = true ] && echo "[VOLUME_PREFIX]: $VOLUME_PREFIX"
        if [ "${RUNNER_TYPE}" != "github" ]; then
          VOL_CCACHE="${VOLUME_PREFIX}-ccache"
          VOL_STAMPS="${VOLUME_PREFIX}-stamps"
          VOL_APT="${VOLUME_PREFIX}-apt"
          docker volume create "${VOL_CCACHE}" || true
          docker volume create "${VOL_STAMPS}" || true
          docker volume create "${VOL_APT}" || true
          # initialize ownership inside volumes so container user can write
          docker run --rm -v "${VOL_CCACHE}:/mnt" busybox sh -c "mkdir -p /mnt && chown ${DOCKER_UID}:${DOCKER_GID} /mnt || true"
          docker run --rm -v "${VOL_STAMPS}:/mnt" busybox sh -c "mkdir -p /mnt && chown -R ${DOCKER_UID}:${DOCKER_GID} /mnt || true"
          docker run --rm -v "${VOL_APT}:/mnt" busybox sh -c "mkdir -p /mnt && chown -R ${DOCKER_UID}:${DOCKER_GID} /mnt || true"
          MOUNT_CCACHE="-v ${VOL_CCACHE}:/build/${BUILD_DIR}/.ccache"
          MOUNT_STAMPS="-v ${VOL_STAMPS}:/build/${BUILD_DIR}/.stamps"
          MOUNT_APT="-v ${VOL_APT}:/var/cache/apt/archives"
        else
          MOUNT_CCACHE="-v ${{ github.workspace }}/.ccache:/build/${BUILD_DIR}/.ccache"
          MOUNT_STAMPS="-v ${{ github.workspace }}/build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.stamps:/build/${BUILD_DIR}/.stamps"
          MOUNT_APT="-v ${{ github.workspace }}/.apt-cache/archives:/var/cache/apt/archives"
        fi
        [ "$debug" = true ] && echo "[MOUNT_CCACHE]: $MOUNT_CCACHE"
        [ "$debug" = true ] && echo "[MOUNT_STAMPS]: $MOUNT_STAMPS"
        [ "$debug" = true ] && echo "[MOUNT_APT]: $MOUNT_APT"
        # on self-hosted runners request a larger container memory; allow override via CONTAINER_MEMORY
        if [ "${RUNNER_TYPE}" != "github" ]; then
          CONTAINER_MEMORY="${CONTAINER_MEMORY:-12g}"
          MEMORY_ARG="--memory=${CONTAINER_MEMORY}"
        else
          MEMORY_ARG=""
        fi
        [ "$debug" = true ] && echo "[MEMORY_ARG]: $MEMORY_ARG"
        
        # create a small script in the workspace to compute a safe -j inside the container
        cat > build_recommend.sh <<'EOF'
        #!/bin/bash
        set -euo pipefail
        if [ "${RUNNER_TYPE:-}" = "github" ]; then
          git config --global --add safe.directory /build || true
        fi
        NB_CORES=$(grep -c '^processor' /proc/cpuinfo || nproc)
        PER_JOB_MB=${PER_JOB_MB:-2000}
        RESERVE_MB=${RESERVE_MB:-2048}
        mem_bytes=0
        if [ -f /sys/fs/cgroup/memory.max ]; then
          memmax=$(cat /sys/fs/cgroup/memory.max)
          if [ "$memmax" != "max" ]; then
            mem_bytes=$memmax
          fi
        fi
        if [ "$mem_bytes" -eq 0 ] 2>/dev/null; then
          if [ -f /sys/fs/cgroup/memory/memory.limit_in_bytes ]; then
            memlim=$(cat /sys/fs/cgroup/memory/memory.limit_in_bytes)
            if [ "$memlim" -lt 9223372036854771712 ] 2>/dev/null; then
              mem_bytes=$memlim
            fi
          fi
        fi
        if [ "$mem_bytes" -eq 0 ] 2>/dev/null; then
          mem_kb=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
          mem_bytes=$((mem_kb*1024))
        fi
        TOTAL_MB=$((mem_bytes/1024/1024))
        USABLE_MB=$((TOTAL_MB-RESERVE_MB))
        if [ "$USABLE_MB" -lt 256 ]; then USABLE_MB=256; fi
        MAX_J_BY_RAM=$((USABLE_MB/PER_JOB_MB))
        if [ "$MAX_J_BY_RAM" -lt 1 ]; then MAX_J_BY_RAM=1; fi
        CANDIDATE_J=$((NB_CORES+2))
        if [ "$CANDIDATE_J" -gt "$MAX_J_BY_RAM" ]; then RECOMMENDED_J=$MAX_J_BY_RAM; else RECOMMENDED_J=$CANDIDATE_J; fi
        if [ "$RECOMMENDED_J" -gt $((NB_CORES*2)) ]; then RECOMMENDED_J=$((NB_CORES*2)); fi
        echo "Using make -j${RECOMMENDED_J} -l${NB_CORES}"
        make -j${RECOMMENDED_J} -l${NB_CORES} image
        EOF
        
        chmod +x build_recommend.sh || true
        # Ensure per-build ccache ownership is correct before running the container
        sudo chown -R ${DOCKER_UID}:${DOCKER_GID} "$BUILD_DIR/.ccache" || true

        # Run the build container. If running on GitHub-hosted runner, tell git to trust /build
        # to avoid 'dubious ownership' errors caused by bind-mounted repos.
        # if [ "$(docker ps -aq -f status=exited -f name=build${{ env.EE_Distro }}.${{ env.DistroCodeName }})" ]; then
        # if [ "$(docker ps -aq -f name=build${{ env.EE_Distro }}.${{ env.DistroCodeName }})" ]; then
        #     # cleanup
        #     docker rm --force --volumes "build${{ env.EE_Distro }}.${{ env.DistroCodeName }}"
        # fi

        # docker volume create ${{ env.DistroCodeName }}-ccache
        # docker create \
        #   --name "${{ env.DistroCodeName }}-ccache" \
        #   -v ${{ env.DistroCodeName }}-ccache:/build/build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.ccache \
        #   debian
          # run: echo "BUILD_NAME=${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}" >> $GITHUB_OUTPUT
          # ${{ github.workspace }}/build.${{ steps.set-build-name.outputs.BUILD_NAME }}-13.0-devel/.ccache
          # ${{ github.workspace }}/build.${{ steps.set-build-name.outputs.BUILD_NAME }}-13.0-devel/.stamps
          # EE_Distro_tag="${{ env.EE_Registry }}/eddict/${DistroCodeName@L}"
          # [pwd]: /root/actions-runner/_work/EddictwareELEC/EddictwareELEC
        # run the container (use debug env values when workflow input `debug` is 'true')
        if [ "$debug" = true ]; then
          ONELOG_VAL=no
          LOGCOMBINE_VAL=never
          MTIMMEDIATE_VAL=yes
          MTDEBUG_VAL=yes
          MTVERBOSE_VAL=yes
          MTPROGRESS_VAL=no
          SHOW_STDOUT_VAL=yes
          SHOW_STDERR_VAL=yes
        else
          ONELOG_VAL=no
          LOGCOMBINE_VAL=fail
          MTIMMEDIATE_VAL=no
          MTDEBUG_VAL=no
          MTVERBOSE_VAL=no
          MTPROGRESS_VAL=no
          SHOW_STDOUT_VAL=no
          SHOW_STDERR_VAL=no
        fi

        DOCKER_ENV_FLAGS="-e ONELOG=${ONELOG_VAL} -e LOGCOMBINE=${LOGCOMBINE_VAL} -e MTIMMEDIATE=${MTIMMEDIATE_VAL} -e MTDEBUG=${MTDEBUG_VAL} -e MTVERBOSE=${MTVERBOSE_VAL} -e MTPROGRESS=${MTPROGRESS_VAL} -e SHOW_STDOUT=${SHOW_STDOUT_VAL} -e SHOW_STDERR=${SHOW_STDERR_VAL}"
        [ "$debug" = true ] && echo "[DOCKER_ENV_FLAGS]: $DOCKER_ENV_FLAGS"

        # only pass --user when running on self-hosted runners; run as root on GitHub-hosted runners
        USER_ARG=""
        if [ "${RUNNER_TYPE}" != "github" ]; then
          USER_ARG="--user ${DOCKER_UID}:${DOCKER_GID}"
        fi
        
        # Ensure the workspace is writable by the container user by initializing ownership inside a short container
        echo "Initializing workspace ownership inside container to ${DOCKER_UID}:${DOCKER_GID}"
        docker run --rm -v ${{ github.workspace }}:/build "${{ needs.init.outputs.output_ee_distro_tag }}" sh -c "chown -R ${DOCKER_UID}:${DOCKER_GID} /build || true"
        docker run --rm ${MEMORY_ARG} \
          --name "build${{ env.EE_Distro }}.${{ env.DistroCodeName }}" \
          -v ${{ github.workspace }}:/build \
          ${MOUNT_CCACHE} \
          ${MOUNT_STAMPS} \
          ${MOUNT_APT} \
          -w /build \
          ${USER_ARG} \
          -e CCACHE_DIR=/build/build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.ccache \
          -e DISABLE_COLORS=no \
          -e MTCOLORS=auto \
          ${DOCKER_ENV_FLAGS} \
          -e DISTRO=${{ env.EE_Distro }} \
          -e PROJECT=${{ env.EE_Project }} \
          -e DEVICE=${{ env.EE_Device }} \
          -e ARCH=${{ env.EE_Arch }} \
          -e BUILDER_NAME=Eddict \
          -e BUILDER_VERSION="13.0-$(date +%Y%m%d)" \
          -e RUNNER_TYPE=${RUNNER_TYPE} \
          "${{ needs.init.outputs.output_ee_distro_tag }}" sh -c "git config --global --add safe.directory /build || true; make -j$((NB_CORES+1)) -l${NB_CORES} image"
          # run the workspace helper script so computation happens inside the container
          # (script will call make with a recommended -j)
        docker_exit_code=$?
        if [ -f build_recommend.sh ]; then
          docker run --rm ${MEMORY_ARG} \
            --name "build-runner-cmd" \
            -v ${{ github.workspace }}:/build \
            ${MOUNT_CCACHE} ${MOUNT_STAMPS} ${MOUNT_APT} \
            -w /build -e RUNNER_TYPE=${RUNNER_TYPE} "${{ needs.init.outputs.output_ee_distro_tag }}" /bin/bash /build/build_recommend.sh || true
        fi
          # --volumes-from ${{ env.DistroCodeName }}-ccache \
          # -e CCACHE_DIR=/build/build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.ccache \
          # --ipc=host \  #  ?? https://docs.docker.com/reference/cli/docker/container/run/#ipc
          # -e THREADCOUNT=75% \
          # --user docker \
          # --user docker \
          # --cpus="12" \
          # --memory="12g" \
          # --memory-swap="-1" \
          # --ipc="host" \
          # --log-driver local \

    - name: github-workspace
      id: ls-ghws
      run: |
        debug=true
        [ "$debug" = true ] && echo "[github.workspace]: ${{ github.workspace }}"
        [ "$debug" = true ] && ls -al ${{ github.workspace }}

    # https://stackoverflow.com/a/57877438
    - uses: actions/upload-artifact@v4
      if: always() && (steps.build-image.outcome == 'failure')
      with:
        name: artifact_logs_${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}
        # use workspace-relative path so the host runner (not the container) can find the logs
        path: build.${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}-13.0-devel/.threads/logs/*.log
        overwrite: true
        include-hidden-files: true

    # cache artifacts are now persisted via actions/cache (restore steps above)

    -
      name: Copy built ${{ env.EE_Distro }} image to archive
      id: image-path
      run: |
        debug=true
        [ "$debug" = true ] && echo "[pwd]: ${{ github.workspace }}"
        if [ -d ${{ github.workspace }}/target ]; then
          lines=$(find ${{ github.workspace }}/target -maxdepth 1 -type f -iname "${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}*.img.gz" 2>/dev/null | wc -l)
          [ "$debug" = true ] && echo "[lines]: $lines"
          if [ $lines -ne 0 ]; then
            pathfilename=$(ls -t ${{ github.workspace }}/target/${{ env.EE_Distro }}-${{ env.EE_Device }}.${{ env.EE_Arch }}*.img.gz | head --lines=1)
            [ "$debug" = true ] && echo "[EE_image_pathfilename]: $pathfilename"
            echo "EE_image_pathfilename=$pathfilename" >> $GITHUB_OUTPUT
            filename="${pathfilename##*/}"
            [ "$debug" = true ] && echo "[EE_image_filename]: $filename"
            echo "EE_image_filename=$filename" >> $GITHUB_OUTPUT
            if [ ! -d /root/target_archive ]; then
              mkdir --parents "/root/target_archive"
            fi
            if [ "$(cp "$pathfilename" "/root/target_archive")" ]; then # --update=older
              echo "Copied built image to /root/target_archive"
            else
              echo "No newer built image to copy to /root/target_archive"
            fi
          else
            echo "No built image found in target directory, skipping copy."
          fi
        else
          echo "No target directory found, skipping copy of built image."
        fi

    - name: Upload built ${{ env.EE_Distro }} image
      if: steps.image-path.outputs.EE_image_pathfilename != ''
      uses: actions/upload-artifact@v4
      with:
        name: "${{ steps.image-path.outputs.EE_image_filename }}"
        path: "${{ steps.image-path.outputs.EE_image_pathfilename }}"

    # - # Temp fix to prevent cache size keeps growing
    #   # https://docs.docker.com/build/ci/github-actions/cache/#local-cache
    #   name: Move cache
    #   run: |
    #     rm -rf /tmp/.buildx-cache-2
    #     mv /tmp/.buildx-cache-2-new /tmp/.buildx-cache-2
 