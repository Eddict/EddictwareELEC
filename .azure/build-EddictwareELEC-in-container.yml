# Azure Pipelines conversion of .github/workflows/build-EddictwareELEC-in-container.yml
# - Trigger: manual (workflow_dispatch equivalent)
# - Parameters mirror the GitHub Action inputs so you can run the pipeline interactively.
# Notes:
# - This pipeline is adapted for Azure Pipelines. Use an ACR service connection for registry auth.
# - If you need to pull builder images from a different registry, set `EE_Registry` accordingly.

name: Build image in container

trigger: none

pr: none

parameters:
  - name: runner
    displayName: Runner
    type: string
    default: github
    values:
      - github
      - self-hosted
  - name: os
    displayName: OS
    type: string
    default: noble
    values:
      - bookworm
      - jammy
      - noble
      - noble-custom
      - plucky
      - questing
      - sid
  - name: arch
    displayName: Arch
    type: string
    default: aarch64
    values:
      - amd64
      - aarch64
      - arm
      - x86_64

variables:
  EE_Distro: EddictwareELEC
  EE_Project: RPi
  EE_Device: RPi4
  # default registry: set to your Azure Container Registry hostname (override as needed)
  EE_Registry: eddict.azurecr.io
  BUILDKIT_PROGRESS: 'auto'
  # ACR service connection (use a service connection name to authenticate to ACR)
  ACR_SERVICE_CONNECTION: 'eddict-acr-connection'
  # Service connection type: 'azurerm' (recommended for ACR) or 'dockerregistry'
  ACR_SERVICE_CONNECTION_TYPE: 'azurerm'

jobs:
- job: init
  displayName: Init
  pool:
    ${{ if eq(parameters.runner, 'self-hosted') }}:
      name: 'Self-Hosted'
    ${{ if ne(parameters.runner, 'self-hosted') }}:
      vmImage: 'ubuntu-latest'
  steps:
  - bash: |
      echo "date=$(date -u +%Y%m%d)"
      echo "##vso[task.setvariable variable=build_date]$(date -u +%Y%m%d)"
    displayName: Get Date

  - bash: |
      DGUID=$(id -u docker 2>/dev/null || echo "0")
      echo "docker-guid=${DGUID}"
      echo "##vso[task.setvariable variable=docker_guid]${DGUID}"
      echo "##vso[task.setvariable variable=DOCKER_GUID]${DGUID}"
    displayName: Get docker guid

  - bash: |
      # Compose image tag (lowercase)
      dTag="${EE_Registry}/eddict/${EE_Distro}-${{ parameters.os }}:latest"
      dTagLower=$(echo "${dTag}" | tr '[:upper:]' '[:lower:]')
      echo "EE_Distro_tag=${dTagLower}"
      echo "##vso[task.setvariable variable=EE_Distro_tag;isOutput=true]${dTagLower}"
    name: composeImage
    displayName: Compose image tag

- job: build
  displayName: Build image in container
  dependsOn: init
  pool:
    ${{ if eq(parameters.runner, 'self-hosted') }}:
      name: 'Self-Hosted'
    ${{ if ne(parameters.runner, 'self-hosted') }}:
      vmImage: 'ubuntu-latest'
  steps:
  - checkout: self
    displayName: Checkout repository
    persistCredentials: true
    clean: true

  - ${{ if and(ne(variables.ACR_SERVICE_CONNECTION, ''), eq(variables.ACR_SERVICE_CONNECTION_TYPE, 'dockerregistry')) }}:
    - task: Docker@2
      displayName: Login to ACR (dockerregistry connection)
      inputs:
        containerRegistry: '$(ACR_SERVICE_CONNECTION)'
        command: login

  - ${{ if and(ne(variables.ACR_SERVICE_CONNECTION, ''), ne(variables.ACR_SERVICE_CONNECTION_TYPE, 'dockerregistry')) }}:
    - task: AzureCLI@2
      displayName: Login to ACR (azurerm connection)
      inputs:
        azureSubscription: '$(ACR_SERVICE_CONNECTION)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          REG_HOST="${EE_Registry:-eddict.azurecr.io}"
          REG_NAME="${REG_HOST%%.*}"
          echo "Logging into ACR ${REG_NAME} (${REG_HOST}) via az acr login"
          az acr login --name "${REG_NAME}"

  - bash: |
      set -euo pipefail
      echo "## Compose values from init job"
      BUILDER_IMAGE="$(dependencies.init.outputs['composeImage.EE_Distro_tag'])"
      echo "Builder image: ${BUILDER_IMAGE}"
      # debug info
      echo "[pwd]: $PWD"
      echo "[NB_CORES]: $(nproc)"

      # Registry login should be handled via the Docker@2 login task (ACR service connection)
      echo "Registry login handled by Docker@2 (ACR service connection if provided)."

      docker --debug image pull "${BUILDER_IMAGE}"

      NB_CORES=$(grep -c '^processor' /proc/cpuinfo || echo 1)
      echo "[NB_CORES]: ${NB_CORES}"

      docker run --rm \
        --name "build${EE_Distro}.${{ parameters.os }}" \
        -v "$BUILD_SOURCESDIRECTORY":/build \
        -w /build \
        -e DISABLE_COLORS=no \
        -e MTCOLORS=auto \
        -e ONELOG=no \
        -e LOGCOMBINE=fail \
        -e MTIMMEDIATE=no \
        -e MTDEBUG=no \
        -e MTVERBOSE=no \
        -e MTPROGRESS=no \
        -e DISTRO=${EE_Distro} \
        -e PROJECT=${EE_Project} \
        -e DEVICE=${EE_Device} \
        -e ARCH=${{ parameters.arch }} \
        -e BUILDER_NAME=Eddict \
        -e BUILDER_VERSION="13.0-$(date +%Y%m%d)" \
        "${BUILDER_IMAGE}" make -j$((NB_CORES+1)) -l${NB_CORES} image
    displayName: Build ${EE_Distro} image

  - bash: |
      # Copy built image to archive if present
      if [ -d "$BUILD_SOURCESDIRECTORY/target" ]; then
        lines=$(find "$BUILD_SOURCESDIRECTORY/target" -maxdepth 1 -type f -iname "${EE_Distro}-${EE_Device}.${{ parameters.arch }}*.img.gz" 2>/dev/null | wc -l)
        if [ "$lines" -ne 0 ]; then
          pathfilename=$(ls -t "$BUILD_SOURCESDIRECTORY/target/${EE_Distro}-${EE_Device}.${{ parameters.arch }}*.img.gz" | head -n1)
          echo "EE_image_pathfilename=$pathfilename"
          filename="${pathfilename##*/}"
          echo "EE_image_filename=$filename"
          echo "##vso[task.setvariable variable=EE_image_pathfilename]${pathfilename}"
          echo "##vso[task.setvariable variable=EE_image_filename]${filename}"
          if [ ! -d /root/target_archive ]; then
            mkdir -p /root/target_archive
          fi
          cp -u "$pathfilename" /root/target_archive || true
        else
          echo "No built image found in target directory"
        fi
      else
        echo "No target directory found, skipping copy"
      fi
    displayName: Copy built image to archive

  - task: PublishPipelineArtifact@1
    displayName: Publish built image (if present)
    inputs:
      targetPath: '$(EE_image_pathfilename)'
      artifact: 'built_image'
      publishLocation: 'pipeline'
    condition: and(succeeded(), ne(variables['EE_image_pathfilename'], ''))

  - bash: |
      set -euo pipefail
      base="${BUILD_SOURCESDIRECTORY}/build.${EE_Distro}-${EE_Device}.${{ parameters.arch }}-13.0-devel"
      has_cache=false
      for path in "${base}/.cache_package_global" "${base}/.ccache" "${base}/.stamps"; do
        if [ -e "$path" ]; then
          echo "Found cache path: $path"
          has_cache=true
          break
        fi
      done
      echo "##vso[task.setvariable variable=HAS_BUILD_CACHE;issecret=false]${has_cache}"
    displayName: Check build cache paths
    condition: always()

  - task: PublishPipelineArtifact@1
    displayName: Publish cache/artifacts
    inputs:
      targetPath: |
        $(Build.SourcesDirectory)/build.${EE_Distro}-${EE_Device}.${{ parameters.arch }}-13.0-devel/.cache_package_global
        $(Build.SourcesDirectory)/build.${EE_Distro}-${EE_Device}.${{ parameters.arch }}-13.0-devel/.ccache
        $(Build.SourcesDirectory)/build.${EE_Distro}-${EE_Device}.${{ parameters.arch }}-13.0-devel/.stamps
      artifact: 'build_cache'
      publishLocation: 'pipeline'
    condition: and(always(), eq(variables['HAS_BUILD_CACHE'], 'true'))

# Usage notes:
# - Set pipeline variables (in pipeline UI or variable group):
#   - `ACR_SERVICE_CONNECTION` (service connection name) to authenticate to ACR
# - Run pipeline manually and choose `runner`, `os`, and `arch` parameters.
