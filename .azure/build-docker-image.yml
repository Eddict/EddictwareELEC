# Azure Pipelines conversion of .github/workflows/build-docker-image.yml
# - Trigger: push to `master-entw`
# - Parameters: `runner` and `environment` (same choices as GH Action)
# - Notes:
#   Recommended: use an Azure Container Registry (ACR) service connection.
#   - Set the pipeline variable `ACR_SERVICE_CONNECTION` to the name of the service connection.
#   Legacy: username/password variables are still supported but not recommended.

name: 'Build build Container'

trigger:
  branches:
    include:
      - master-entw

pr: none

parameters:
  - name: runner
    displayName: Runner
    type: string
    default: azure
    values:
      - azure
      - self-hosted
  - name: environment
    displayName: Environment
    type: string
    default: noble
    values:
      - bookworm
      - jammy
      - noble
      - noble-custom
      - plucky
      - questing
      - sid

variables:
  RUNNER_TOOL_CACHE: /toolcache
  BUILDKIT_PROGRESS: 'auto'
  # Name of an ACR service connection (set this in the pipeline UI)
  ACR_SERVICE_CONNECTION: 'eddict-acr-connection'

jobs:
- job: Build
  displayName: Build and push Docker image
  pool:
    ${{ if eq(parameters.runner, 'self-hosted') }}:
      name: 'edazpool'
    ${{ if ne(parameters.runner, 'self-hosted') }}:
      vmImage: 'ubuntu-latest'

  steps:
  - bash: |
      echo "## Get docker guid and set pipeline variable"
      DGUID=$(id -u docker 2>/dev/null || echo "0")
      echo "docker-guid=${DGUID}"
      echo "##vso[task.setvariable variable=docker_guid;issecret=false]${DGUID}"
    displayName: Get docker guid

  - bash: |
      echo "## Compose image tag based on runner and environment"
      REGISTRY=eddict.azurecr.io
      REGISTRY=$(echo "${REGISTRY}" | tr '[:upper:]' '[:lower:]')
      echo "REGISTRY=${REGISTRY}"

      # Derive a non-secret registry host (strip protocol and path)
      REGISTRY_HOST="$(echo "${REGISTRY}" | sed -E 's#https?://##; s#/.*$##')"
      echo "REGISTRY_HOST=${REGISTRY_HOST}"
      echo "##vso[task.setvariable variable=REGISTRY_HOST;issecret=false]${REGISTRY_HOST}"

      # Build repository name: Azure provides BUILD_REPOSITORY_NAME
      REPO_NAME=${BUILD_REPOSITORY_NAME}
      REPO_NAME=$(echo "${REPO_NAME}" | tr '[:upper:]' '[:lower:]')
      echo "REPO_NAME=${REPO_NAME}"

      IMAGE_REPO="${REPO_NAME}-${{ parameters.environment }}"
      IMAGE_REPO=$(echo "${IMAGE_REPO}" | tr '[:upper:]' '[:lower:]')
      echo "IMAGE_REPO=${IMAGE_REPO}"

      EE_Distro_tag="${REGISTRY}/${IMAGE_REPO}"
      EE_Distro_tag_lower=$(echo "${EE_Distro_tag}:latest" | tr '[:upper:]' '[:lower:]')
      echo "EE_Distro_tag=${EE_Distro_tag_lower}"
      echo "##vso[task.setvariable variable=IMAGE_REPO;issecret=false]${IMAGE_REPO}"
      echo "##vso[task.setvariable variable=EE_Distro_tag;issecret=false]${EE_Distro_tag_lower}"
      echo "##vso[task.setvariable variable=REGISTRY;issecret=false]${REGISTRY}"
      # Explicit split: tag name and fully-qualified build tag
      IMAGE_TAG=latest
      BUILD_TAG="${EE_Distro_tag_lower}"
      echo "IMAGE_TAG=${IMAGE_TAG}"
      echo "BUILD_TAG=${BUILD_TAG}"
      echo "##vso[task.setvariable variable=IMAGE_TAG;issecret=false]${IMAGE_TAG}"
      echo "##vso[task.setvariable variable=BUILD_TAG;issecret=false;isOutput=true]${BUILD_TAG}"
    displayName: Compose image tag

  - bash: |
      echo "## Registry selection: prefer ACR service connection"
      if [ -n "$(ACR_SERVICE_CONNECTION)" ]; then
        echo "ACR service connection is set: $(ACR_SERVICE_CONNECTION)"
      else
        echo "No ACR service connection set; pipeline will attempt legacy docker login using pipeline secrets."
      fi
    displayName: Registry selection

  - bash: |
      echo "## Prepare build (Docker@2 will perform build/push when using ACR service connection)"
    displayName: Prepare build
  - bash: |
      echo "## Verify ACR service connection is set"
      if [ -z "$ACR_SERVICE_CONNECTION" ]; then
        echo "ERROR: ACR_SERVICE_CONNECTION pipeline variable is empty."
        echo "Create an Azure Container Registry service connection and set the pipeline variable 'ACR_SERVICE_CONNECTION' to its name."
        echo "See project settings -> Service connections in Azure DevOps, or set the variable in the pipeline YAML."
        exit 1
      fi
      echo "Using ACR service connection: $ACR_SERVICE_CONNECTION"
    displayName: Require ACR service connection

  - task: Docker@2
    displayName: Docker login (ACR)
    inputs:
      containerRegistry: '$(ACR_SERVICE_CONNECTION)'
      command: login

  - task: Docker@2
    displayName: Build image
    inputs:
      command: build
      Dockerfile: 'tools/docker/${{ parameters.environment }}/Dockerfile'
      buildContext: '$(Build.SourcesDirectory)'
      tags: '$(BUILD_TAG)'
      # alternative: '$(REGISTRY)/$(IMAGE_REPO):$(IMAGE_TAG)'
      arguments: >-
        --label org.opencontainers.image.source=https://github.com/Eddict/EddictwareELEC
        --label org.opencontainers.image.ref.name=$(EE_Distro_tag)
        --build-arg USER_UID=$(docker_guid)

  - task: Docker@2
    displayName: Push image (ACR)
    inputs:
      containerRegistry: '$(ACR_SERVICE_CONNECTION)'
      command: push
      repository: '$(IMAGE_REPO)'
      tags: '$(IMAGE_TAG)'
  - bash: |
      echo "## Push fully-qualified build tag"
      echo "Local images:"
      /usr/bin/docker images --format "{{.Repository}}:{{.Tag}} {{.ID}} {{.Size}}"
      echo "Pushing ${BUILD_TAG}"
      /usr/bin/docker push ${BUILD_TAG}
    displayName: Push fully-qualified BUILD_TAG (ACR)

  - bash: |
      echo "## Attestation placeholder"
      echo "Subject: ${BUILD_TAG}"
      # In GitHub Actions the actions/attest-build-provenance is used. You can integrate Cosign or other attestation tooling here.
    displayName: Generate artifact attestation (placeholder)

  - bash: |
      echo "Done. The image was built and pushed to: ${BUILD_TAG}"
    displayName: Done

# Usage notes:
# - Create pipeline variables (in UI or variable group) for secrets:
#   - REGISTRY_PWD (secret)
#   - REGISTRY_USER
#   - Optionally provide GITHUB_TOKEN and GITHUB_ACTOR if you want GH-specific login behavior
# - To run manually, choose parameters `runner` and `environment` in the Run pipeline dialog.
